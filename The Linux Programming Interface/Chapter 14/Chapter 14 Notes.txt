- A DEVICE SPECIAL FILE corresponds to a DEVICE on the system. Within the KERNEL, EACH DEVICE TYPE has a
corresponding DEVICE DRIVER, which HANDLES ALL I/O REQUESTS for the device. A "DEVICE DRIVER" is a UNIT of
KERNEL CODE that IMPLEMENTS a SET OF OPERATIONS that (normally) correspond to INPUT AND OUTPUT ACTIONS on an
ASSOCIATED PIECE of HARDWARE. The API PROVIDED by device drivers is FIXED, and INCLUDES OPERATIONS corresponding
to the system calls "open()", "close()", "write()", "read()", "mmap()", and "ioctl()". The FACT that EACH DEVICE
DRIVER provides a CONSISTENT INTERFACE, HIDING the DIFFERENCES in operation of individual devices, ALLOWS for
UNIVERSALITY of I/O.

- Some DEVICES are REAL, such as mice, disks, speakers, monitors, etc. Others are VIRTUAL, meaning that there is
NO CORRESPONDING HARDWARE; RATHER, the KERNEL provides (VIA a DEVICE DRIVER) an ABSTRACT DEVICE with an API that
is THE SAME as a REAL DEVICE.

- Devices can be DIVIDED into TWO TYPES:
    a) CHARACTER DEVICES - handle data on a CHARACTER-BY-CHARACTER BASIS. TERMINALS and KEYBOARDS are EXAMPLES
                           of CHARACTER DEVICES.

    b) BLOCK DEVICES - handle data a BLOCK AT A TIME. The SIZE of a BLOCK depends on the TYPE of DEVICE, but is
                       TYPICALLY some MULTIPLE of 512 bytes. EXAMPLES of BLOCK DEVICES include DISKS.

- Device files appear within the file system, just like other files, usually under the "/dev" directory.
The SUPERUSER can CREATE a DEVICE FILE using the "mknod" command, and the SAME TASK can be PERFORMED in a
PRIVILEGED PROGRAM ('CAP_MKNOD') using the "mknod()" system call.

                Note: The ONLY PURPOSE for which "mknod()" ("make file-system i-node") is REQUIRED NOWADAYS is
                      to CREATE DEVICE FILES, which is NOT a COMMON APPLICATION REQUIREMENT. We can also use
                      "mknod()" to create FIFOs, but the "mkfifo()" function is PREFERRED for this task.
                      Historically, SOME UNIX implementations ALSO USED "mknod()" for CREATING DIRECTORIES,
                      but this USE has now been REPLACED by the "mkdir()" system call. Nevertheless, SOME UNIX
                      implementations - but NOT Linux - PRESERVE this CAPABILITY in "mknod()" for BACKWARD
                      COMPATIBILITY.

- In EARLIER VESIONS of Linux, "/dev" CONTAINED ENTRIES for ALL POSSIBLE DEVICES on the system, EVEN IF such
devices WEREN'T ACTUALLY CONNECTED to the system. This mean that "/dev" could contain literally THOUSANDS of
UNUSED ENTRIES, SLOWING the TASK of programs that NEEDED to SCAN the CONTENTS in that directory, and making it
IMPOSSIBLE to use the contents of the directory as a means of DISCOVERING WHICH DEVICES were ACTUALLY PRESENT
on the system. In Linux 2.6, these PROBLEMS are SOLVED by the "udev" program. The "udev" program RELIES on the
"sysfs" file system, which EXPORTS INFORMATION about DEVICES and OTHER KERNEL OBJECTS into USER SPACE via a
PSEUDO-FILE SYSTEM mounted under "/sys".

- EACH DEVICE FILE has a "MAJOR ID NUMBER" and a "MINOR ID NUMBER":
       1) major ID - IDENTIFIES the GENERAL CLASS of DEVICE, and is USED by the KERNEL to LOOK UP the
                     APPROPRIATE DRIVER for this TYPE of DEVICE;
       2) minor ID - UNIQUELY IDENTIFIES a PARTICULAR DEVICE wihin a GENERAL CLASS.

- The major and minor IDs of a device file are DISPLAYED by the "ls -l" command.

- A device's major and minor IDs are RECORDED in the I-NODE for the DEVICE FILE. Each device driver REGISTERS
its ASSOCIATION with a SPECIFIC MAJOR DEVICE ID, and this association PROVIDES the CONNECTION BETWEEN the
DEVICE SPECIAL FILE and the DEVICE DRIVER. The NAME of the DEVICE FILE has NO RELEVANCE when the kernel looks
for the device driver.

- On Linux 2.4 and EARLIER, the TOTAL NUMBER OF DEVICES on the system is LIMITED by the fact that device major
and minor IDs are EACH REPRESENTED using JUST 8-BITS. Linux 2.6 EASES this LIMITATION by using MORE BITS to
HOLD the major and minor device IDs (respectively, 12 and 20 bits).

##############################################################################################################
- Regular files and directories TYPICALLY RESIDE on HARD DISK DEVICES (files and directories MAY ALSO EXIST on
OTHER DEVICES, such as CD-ROMs, flash memory cards, and virtual disks, but for the present discussion, we are
primarily interested in hard disk devices).

- A HARD DISK DRIVE is a MECHANICAL DEVICE consisting of ONE OR MORE PLATTERS that ROTATE at HIGH SPEED (of the
order of thousands of revolutions per minute). MAGNETICALLY ENCODED INFORMATION on the DISK SURFACE is RETRIEVED
or MODIFIED by the READ/WRITE HEADS that MOVE RADIALLY ACROSS the DISK. Physically, INFORMATION on the DISK
SURFACE is LOCATED on a SET of CONCENTRIC CIRCLES called "TRACKS". Tracks themselves are DIVIDED into a number
of "SECTORS", each of which CONSISTS of a SERIES of PHYSICAL BLOCKS. Physical blocks are TYPICALLY 512-BYTES
(or some MULTIPLE thereof) in SIZE, and REPRESENT the SMALLEST UNIT OF INFORMATION that the DRIVE can READ or
WRITE.

- Although MODERN DISKS are FAST, READING and WRITING INFORMATION on the disk STILL TAKES SIGNIFICANT TIME.
The DISK HEAD must FIRST MOVE to the APPROPRIATE TRACK (seek time), then the DRIVE must WAIT UNTIL the
APPROPRIATE SECTOR ROTATES UNDER THE HEAD (rotational latency), and FINALLY the REQUIRED BLOCKS must be
TRANSFERRED (transfer time). The TOTAL TIME REQUIRED to CARRY OUT such an operation is TYPICALLY of the ORDER
of MILLISECONDS. By COMPARISON, MODERN CPUs are CAPABLE of EXECUTING MILLIONS OF INSTRUCTIONS in this time.

- Each DISK is DIVIDED into ONE OR MORE (nonoverlapping) "PARTITIONS". Each PARTITION is TREATED by the KERNEL
as a SEPARATE DEVICE residing under the "/dev" directory.

                Note:  The system administrator determines the NUMBER, TYPE, and SIZE of PARTITIONS on a disk
                     using the "fdisk" command. The command "fdisk -l" lists all aprtitions on a disk.
                     The LINUX-SPECIFIC "/proc/partitions" file lists the major and minor device numbers, size,
                     and name of each disk partition on the system.

- A DISK PARTITION may HOLD ANY TYPE of INFORMATION, but USUALLY CONTAINS one of the following:
        a) A "FILE SYSTEM" holding REGULAR FILES and DIRECTORIES;
        b) A "DATA AREA" accessed as a RAW-MODE DEVICE (as described in Section 13.6; some database management
           systems use this technique);
        c) A "SWAP AREA" used by the KERNEL for MEMORY MANAGEMENT.

- A SWAP AREA is CREATED using the "mkswap(8)" command. A PRIVILEGED PROCESS (CAP_SYS_ADMIN) can USE the
"swapon()" system call to NOTIFY the KERNEL that a DISK PARTITION is to be USED as a SWAP AREA. The "swapoff()"
system call performs the CONVERSE function, TELLING the KERNEL to CEASE USING a DISK PARTITION as a SWAP AREA.
These system calls are NOT STANDARDIZED in SUSv3, but they EXIST on MANY UNIX implementations.

                Note:  The LINUX-SPECIFIC "/proc/swaps" file can be used to DISPLAY INFORMATION about the
                     CURRENTLY ENABLED SWAP AREAS on the system. This information INCLUDES the SIZE of EACH
                     SWAP AREA and the AMOUNT of the AREA that is in USE.

##############################################################################################################
- A FILE SYSTEM is an ORGANIZED COLLECTION of REGULAR FILES and DIRECTORIES. A FILE SYSTEM is CREATED using the
"mkfs" command.

- One of the STRENGTHS of Linux is that it SUPPORTS a WIDE VARIETY of FILE SYSTEMS, including the following:
      a) The traditional "ext2" file system;
      b) Various NATIVE UNIX file systems such as the "Minix", "System V", and "BSD" file systems;
      c) Microsoft's "FAT", "FAT32", and "NTFS" file systems;
      d) The ISO 9660 CD-ROM file system;
      e) Apple Macintosh's HFS;
      f) A RANGE of NETWORK FILE SYSTEMS, including Sun's widely used "NFS", IBM and Microsoft's "SMB",
         Novell's "NCP", and the "Coda" file system developed at Carnegie Mellong University;
      g) A RANGE of JOURNALING FILE SYSTEMS, including "ext3", "ext4", "Reiserfs", "JFS", "XFS", and "Btrfs".

- The file-system types CURRENTLY KNOWN by the KERNEL can be VIEWED in the LINUX-SPECIFIC "/proc/filesystems"
file.

                Note:  Linux 2.6.14 added the "Filesystem in Userspace" (FUSE) facility. This mechanism adds
                     hooks to the kernel that allow a file system to be completely implemented via a
                     user-space program, without needing to patch or recompile the kernel.

- For many years, the MOST WIDELY USED FILE SYSTEM on Linux was "ext2", the "Second Extended File System",
which is the SUCCESSOR to the ORIGINAL Linux file system, "ext". In more recent times, the USE of "ext2" has
DECLINED in FAVOR of VARIOUS JOURNALING FILE SYSTEMS. Sometimes, it is USEFUL to DESCRIBE GENERIC FILE-SYSTEM
CONCEPTS in TERMS of a SPECIFIC FILE-SYSTEM IMPLEMENTATION, and for this purpose, we use "ext2" as an example
at various points later in this chapter.

- The BASIC UNIT for ALLOCATING SPACE in a FILE SYSTEM is a "LOGICAL BLOCK", which is some MULTIPLE of
CONTIGUOUS PHYSICAL BLOCKS on the DISK DEVICE on which the file system resides. For example, the LOGICAL BLOCK
SIZE on "ext2" is 1024, 2048, or 4096 bytes (the LOGICAL BLOCK SIZE is SPECIFIED as an ARGUMENT of the
"mkfs(8)" command USED to BUILD the FILE SYSTEM).

- A FILE SYSTEM contains the following PARTS:
       - BOOT BLOCK: This is ALWAYS the FIRST BLOCK in a FILE SYSTEM. The BOOT BLOCK is NOT USED by the FILE
                     SYSTEM; RATHER, it CONTAINS INFORMATION used to BOOT the OPERATING SYSTEM. Although ONLY
                     ONE BOOT BLOCK is NEEDED by the OPERATING SYSTEM, ALL FILE SYSTEMS have a BOOT BLOCK
                     (MOST of which are UNUSED).
                     
       - SUPERBLOCK: This is a SINGLE BLOCK, IMMEDIATELY FOLLOWING the BOOT BLOCK, which contains PARAMETER
                     INFORMATION about the FILE SYSTEM, including:
                       - the SIZE of the I-NODE TABLE;
                       - the SIZE of LOGICAL BLOCKS in this FILE SYSTEM;
                       - the SIZE of the FILE SYSTEM in LOGICAL BLOCKS.
                     Different file systems RESIDING on the SAME PHYSICAL DEVICE can be of DIFFERENT TYPES and
                     SIZES, and have DIFFERENT PARAMETER SETTINGS (e.g., block size). This is ONE of the
                     REASONS for SPLITTING a DISK into MULTIPLE PARTITIONS.

       - I-NODE TABLE: Each file or directory in the file system has a UNIQUE ENTRY in the I-NODE TABLE.
                       This entry RECORDS VARIOUS INFORMATION about the FILE. The I-NODE TABLE is sometimes
                       ALSO CALLED the "I-LIST".

       - DATA BLOCKS: The GREAT MAJORITY OF SPACE in a file system is USED for the BLOCKS OF DATA that FORM
                      the FILES and DIRECTORIES RESIDING in the FILE SYSTEM.

                Note:  In the SPECIFIC CASE of the "ext2" file system, the picture is somewhat MORE COMPLEX
                     than described above. After the initial boot block, the file system is broken into a set
                     of equal-sized BLOCK GROUPS. Each block group contains a copy of the superblock,
                     parameter information about the block group, and then the i-node table and data blocks
                     for this block group. By attempting to store all of the blocks of a file within the same
                     block group, the "ext2" file system aims to reduce seek time when sequentially accessing
                     a file.

##############################################################################################################
- A file system's I-NODE TABLE contains ONE I-NODE (short for "INDEX NODE") for EACH FILE residing in the file
system. I-NODES are IDENTIFIED NUMERICALLY by their SEQUENTIAL LOCATION in the I-NODE TABLE. The "I-NODE NUMBER"
(or simply "I-NUMBER") of a FILE is the FIRST FIELD DISPLAYED by the "ls -li" command. The INFORMATION MAINTAINED
in an I-NODE includes the following:
       a) File type (e.g., a regular file, directory, symbolic link, character device);

       b) Owner (also referred to as the UID) for the file;

       c) Group (also referred to as the GID) for the file;

       d) Access permissions for three categories of user: - "owner" (sometimes referred to as "user");
                                                           - "group";
                                                           - "other" (the rest of the world).

       e) Three timestamps: - time of last access to the file (shown by "ls -lu");
                            - time of last modification of the file (the default time shown by "ls -l");
                            - time of last status change (last change to i-node information, shown by "ls -lc").
          As on OTHER UNIX implementations, it is NOTABLE that MOST Linux file systems DON'T RECORD the CREATION
          TIME of the FILE.

       f) Number of hard links to the file;

       g) Size of the file in bytes;

       h) Number of blocks actually allocated to the file, measured in units of 512-byte blocks. There may not be
          a one-to-one correspondence (bijection) between this number and the size of the file in bytes, since a
          file can contain holes, and thus require fewer allocated blocks than would be expected according to its
          nominal size in bytes;

       i) Pointers to the data blocks of the file.

- Like MOST UNIX file systems, the "ext2" file system DOESN'T STORE the DATA BLOCKS of a file CONTIGUOUSLY or
EVEN in SEQUENTIAL ORDER (though it DOES ATTEMPT to STORE them CLOSE TO ONE ANOTHER). To LOCATE the FILE DATA
BLOCKS, the KERNEL MAINTAINS a SET of POINTERS in the I-NODE. The system used for doing this on the "ext2" file
system is shown in Figure 14-2 (<see the main text, page 258).

                Note:  Removing the need to store the blocks of a file contiguously allows the file system to
                     use space in an EFFICIENT WAY. In particular, it REDUCES the INCIDENCE of "FRAGMENTATION"
                     of FREE DISK SPACE - the WASTAGE CREATED by the EXISTENCE of NUMEROUS PIECES of
                     NONCONTIGUOUS FREE SPACE, all of which are TOO SMALL to USE. Put conversely, we could say
                     that the ADVANTAGE of EFFICIENTLY USING the FREE DISK SPACE is PAID FOR by FRAGMENTING FILES
                     in the FILLED DISK SPACE.

- Under "ext2", EACH I-NODE contains 15 pointers. The first 12 of these pointers (numbered 0 to 11) POINT to the
LOCATION in the file system of the FIRST 12 DATA BLOCKS of the file. The NEXT POINTER is a "POINTER TO A BLOCK OF
POINTERS" that give the LOCATIONS of the THIRTEENTH and SUBSEQUENT DATA BLOCKS of the file. The NUMBER OF
POINTERS in this block DEPENDS on the BLOCK SIZE (LOGICAL) of the FILE SYSTEM. Each pointer requires 4 or 8 bytes
(sizeof(void*)) so there may be from 256 (or 128) pointers (for a 1024-byte block size) to 1024 (or 512) pointers
(for a 4096-byte block size). This ALLOWS for QUITE LARGE FILES. For EVEN LARGER FILES, the FOURTEENTH POINTER
is a "DOUBLE INDIRECT POINTER" - it POINTS to BLOCKS OF POINTERS that in TURN POINT to BLOCKS OF POINTERS
that in TURN POINT to DATA BLOCKS of the file. And should the NEED for a TRULY ENORMOUS FILE ARISE, there is a
FURTHER LEVEL of INDIRECTION: the LAST POINTER in the I-NODE is a "TRIPLE-INDIRECT POINTER" (<see Figure 14-2,
page 258).

- The SEEMINGLY COMPLEX SYSTEM is DESIGNED to SATISFY a number of REQUIREMENTS. To begin with, it ALLOWS the
I-NODE STRUCTURE to be a FIXED SIZE, while at the same time ALLOWING for FILES of an ARBITRARY SIZE.
Additionally, it ALLOWS the file system to STORE the BLOCKS of a file NONCONTIGUOUSLY, while ALSO ALLOWING the
DATA to be ACCESSED RANDOMLY via "lseek()"; the KERNEL JUST NEEDS to CALCULATE WHICH POINTER(S) to FOLLOW. 
Finally, for SMALL FILES, which form the OVERWHELMING MAJORITY OF FILES on MOST SYSTEMS, this scheme ALLOWS the
FILE DATA BLOCKS to be ACCESSED RAPIDLY via the DIRECT POINTERS of the I-NODE.

                Note:  As an example, the author measured one system containing somewhat more than 150,000 files.
                     Just over 30% of the files were less than 1000 bytes in size, and 80% occupied 10,000 bytes
                     or less. Assuming a 1024-byte logical block size, all of the latter files could be
                     referenced using just the 12 direct pointers, which can refer to blocks containing a total
                     of 12,288 bytes (12*1024). Using a 4096-byte logical block size, this limit rises to
                     49,512 bytes (95% of the files on the system fell under that limit).

- This design ALSO ALLOWS for ENORMOUS FILE SIZES; for a logical block size of 4096 bytes, the THEORETICAL
LARGEST FILE SIZE is SLIGTHLY MORE than 1024*1024*1024*4096, or APPROXIMATELY 4 TERABYTES (4096 GB). (We say
"SLIGHTLY MORE" because of the BLOCKS POINTED TO by the DIRECT, INDIRECT, and DOUBLE INDIRECT POINTERS. These are
INSIGNIFICANT COMPARED to the RANGE that can be POINTED TO by the TRIPLE INDIRECT POINTER).

- One OTHER BENEFIT conferred by this design is that files can have HOLES. RATHER than ALLOCATE BLOCKS of NULL
BYTES for the HOLES in a file, the FILE SYSTEM can JUST MARK (with the value 0) APPROPRIATE POINTERS in the
I-NODE and in the indirect pointer blocks to indicate that they DON'T REFER to ACTUAL DISK BLOCKS.

##############################################################################################################
- Each of the FILE SYSTEMS AVAILABLE on Linux DIFFERS in the DETAILS of its IMPLEMENTATION. Such DIFFERENCES
include, for example, the WAY in which the BLOCKS of a FILE are ALLOCATED and the MANNER in which DIRECTORIES
are ORGANIZED. If every program that worked with files NEEDED to UNDERSTAND the SPECIFIC DETAILS of EACH FILE
SYSTEM, the TASK of WRITING PROGRAMS that WORKED WITH ALL of the DIFFERENT FILE SYSTEMS would be NEARLY
IMPOSSIBLE. The "VIRTUAL FILE SYSTEM" (VFS, sometimes ALSO REFERRED TO as the "VIRTUAL FILE SWITCH") is a KERNEL
FEATURE that RESOLVES this PROBLEM by CREATING an ABSTRACTION LAYER for FILE-SYSTEM OPERATIONS <see Figure 14-3,
page 259>. The IDEAS BEHIND the VFS are STRAIGHTFORWARD:
       1) The VFS defines a GENERIC INTERFACE for FILE-SYSTEM OPERATIONS. All programs that work with files
          SPECIFY their OPERATIONS in TERMS OF this GENERIC INTERFACE.

       2) Each file system PROVIDES an IMPLEMENTATION for the VFS INTERFACE.

- Under this scheme, programs ONLY NEED TO UNDERSTAND the VFS INTERFACE and can IGNORE DETAILS of INDIVIDUAL
FILE-SYSTEM IMPLEMENTATIONS.

- The VFS interface INCLUDES OPERATIONS corresponding to ALL of the USUAL SYSTEM CALLS for WORKING with FILE
SYSTEMS and DIRECTORIES, such as "open()", "read()", "write()", "lseek()", "close()", "truncate()", "stat()",
"mount()", "umount()", "mmap()", "mkdir()", "link()", "unlink()", "symlink()", and "rename()".

- The VFS ABSTRACTION LAYER is CLOSELY MODELED on the TRADITIONAL UNIX FILE-SYSTEM MODEL. Naturally, some file
systems - especially NON-UNIX file systems - DON'T SUPPORT ALL of the VFS operations (e.g., Microsoft's VFAT
DOESN'T SUPPORT the NOTION of SYMBOLIC LINKS, created using "symlink()"). In such cases, the UNDERLYING FILE
SYSTEM PASSES an ERROR CODE back to the VFS LAYER indicating the LACK OF SUPPORT, and the VFS in turn PASSES this
ERROR CODE back to the APPLICATION.

##############################################################################################################
- The "ext2" file system is a GOOD EXAMPLE of a TRADITIONAL UNIX FILE SYSTEM, and SUFFERS from a CLASSIC
LIMITATION of such file systems: after a SYSTEM CRASH, a FILE UPDATE may have been ONLY PARTIALLY COMPLETED,
and the FILE-SYSTEM METADATA (directory entries, i-node information, and file data block pointers) MAY BE in an
INCONSISTENT STATE, so that the file system MIGHT be FURTHER DAMAGED if these INCONSISTENCIES are NOT REPAIRED.
A FILE-SYSTEM CONSISTENCY CHECK ensures the CONSISTENCY of the FILE-SYSTEM METADATA. Where possible, REPAIRS are
PERFORMED; otherwise, INFORMATION that is NOT RETRIEVABLE (POSSIBLY including FILE DATA) is DISCARDED.

- The PROBLEM is that a CONSISTENCY CHECK requires EXAMINING the ENTIRE FILE-SYSTEM. On a SMALL file system,
this MAY TAKE anything from SEVERAL SECONDS to a FEW MINUTES. On a LARGE file system, this MAY REQUIRE SEVERAL
HOURS, which is a SERIOUS PROBLEM for SYSTEMS that MUST MAINTAIN HIGH AVAILABILITY (e.g., network servers).

- Journaling file systems ELIMINATE the NEED for LENGTHY file-system CONSISTENCY CHECKS after a system crash.
A journaling file system LOGS (JOURNALS) ALL METADATA UPDATES to a SPECIAL ON-DISK JOURNAL FILE before they are
ACTUALLY CARRIED OUT. The UPDATES are LOGGED in GROUPS of RELATED METADATA UPDATES ("TRANSACTIONS"). In the event
of a system crash in the middle of a transaction, ON SYSTEM REBOOT, the LOG can be USED to RAPIDLY REDO ANY
INCOMPLETE UPDATES and BRING the file system BACK to a CONSISTENT STATE (to borrow database parlance, we can say
that a journaling file system ENSURES that FILE METADATA TRANSACTIONS are ALWAYS "COMMITED" as a COMPLETE UNIT).
Even VERY LARGE journaling file systems can TYPICALLY be AVAILABLE WITHIN SECONDS after a system crash, MAKING
them VERY ATTRACTIVE for SYSTEMS with HIGH-AVAILABILITY REQUIREMENTS.

- The MOST NOTABLE DISADVANTAGE of JOURNALING is that it ADDS TIME to FILE UPDATES, though good design can make
this overhead low.

                Note:  Some journaling file systems ONLY ENSURE the CONSISTENCY of FILE METADATA. Because they
                     DON'T LOG FILE DATA, DATA MAY STILL BE LOST in the event of a crash. The "ext3", "ext4",
                     and "Reiserfs" file systems PROVIDE OPTIONS for LOGGING DATA UPDATES, but, DEPENDING on the
                     WORKLOAD, this MAY RESULT in LOWER FILE I/O PERFORMANCE.

- The journaling file systems AVAILABLE for Linux include the following:
        a) "Reiserfs" - the FIRST of the journaling file systems to be INTEGRATED into the KERNEL (in version
                        2.4.1). "Reiserfs" provides a FEATURE called "TAIL PACKING" (or "TAIL MERGING"): SMALL
                        FILES (and the FINAL FRAGMENT of LARGER FILES) are PACKED into the SAME DISK BLOCKS as
                        the FILE METADATA. Because MANY SYSTEMS have (and some applications CREATE) LARGE NUMBERS
                        of SMALL FILES, this can SAVE a SIGNIFICANT AMOUNT of DISK SPACE;

        b) "ext3" - the RESULT of a PROJECT to ADD JOURNALING to "ext2" with MINIMAL IMPACT. The MIGRATION PATH
                    from "ext2" to "ext3" is VERY EASY (NO BACKUP and RESTORE are REQUIRED), and it is POSSIBLE
                    to MIGRATE in the REVERSE DIRECTION AS WELL. The "ext3" file system was INTEGRATED into the
                    KERNEL in version 2.4.15;

        c) "JFS" - DEVELOPED at IBM. It was INTEGRATED into the KERNEL in version 2.4.20;

        d) "XFS" - ORIGINALLY DEVELOPED by Silicon Graphics (SGI) in the EARLY 1990s for Irix, its PROPRIETARY
                   UNIX implementation. In 2001, XFS was PORTED to Linux and MADE AVAILABLE as a FREE SOFTWARE
                   PROJECT. XFS was INTEGRATED into the KERNEL in version 2.4.24;

- SUPPORT for the various file systems is ENABLED using KERNEL OPTIONS that are SET under the "FILE SYSTEMS"
menu WHEN CONFIGURING the KERNEL.

- At the time of writing, work is in progress on TWO OTHER FILE SYSTEMS that PROVIDE JOURNALING and a RANGE of
OTHER ADVANCED FEATURES:
        a) "ext4" - the SUCCESSOR to "ext3". The FIRST PIECES of the implementation were ADDED in KERNEL 2.6.19,
                    and VARIOUS FEATURES were added in LATER KERNEL VERSIONS. Among the PLANNED (or ALREADY 
                    IMPLEMENTED) FEATURES for "ext4" are:
                        - EXTENTS (RESERVATION of CONTIGUOUS BLOCKS of STORAGE) and OTHER ALLOCATION FEATURES
                          that AIM to REDUCE FILE FRAGMENTATION;
                        - ONLINE FILE-SYSTEM DEFRAGMENTATION;
                        - FASTER FILE-SYSTEM CHECKING;
                        - SUPPORT for NANO-SECOND TIMESTAMPS.

        b) "Btrfs" - a NEW file system DESIGNED from the GROUND UP to PROVIDE a RANGE of MODERN FEATURES,
                     including: 
                        - EXTENTS;
                        - WRITABLE SNAPSHOTS (which provide EQUIVALENT FUNCTIONALITY to METADATA and DATA
                          JOUNRALING);
                        - CHECKSUMS on DATA and METADATA;
                        - ONLINE FILE-SYSTEM CHECKING;
                        - ONLINE FILE-SYSTEM DEFRAGMENTATION;
                        - SPACE-EFFICIENT PACKING of SMALL FILES;
                        - SPACE-EFFICIENT INDEXED DIRECTORIES;
                     It was INTEGRATED into the KERNEL in version 2.6.29;

##############################################################################################################
- On Linux, as on OTHER UNIX systems, ALL FILES from ALL FILE SYSTEMS reside under a SINGLE DIRECTORY TREE.
At the BASE of this TREE is the ROOT DIRECTORY, "/" (slash). Other file systems are MOUNTED under the ROOT
DIRECTORY and APPEAR as SUBTREES within the OVERALL HIERARCHY. The SUPERUSER uses a command of the following
form to MOUNT a FILE SYSTEM:
         $ mount 'device' 'directory'

- This command ATTACHES the FILE SYSTEM on the named "device" into the DIRECTORY HIERARCHY at the specified
"directory" - the file system's MOUNT POINT. It is POSSIBLE to CHANGE the LOCATION at which a FILE SYSTEM is
MOUNTED - the FILE SYSTEM is UNMOUNTED using the "umount" command, and then MOUNTED ONCE MORE at a DIFFERENT
POINT.

                Note:  With Linux 2.4.19 and LATER, things became MORE COMPLICATED. The KERNEL now SUPPORTS
                     PER-PROCESS "MOUNT NAMESPACES". This means that EACH PROCESS POTENTIALLY has its OWN SET
                     of FILE-SYSTEM MOUNT POINTS, and thus MAY SEE a DIFFERENT SINGLE DIRECTORY HIERARCHY from
                     OTHER PROCESSES.

- To LIST the CURRENTLY MOUNTED FILE SYSTEMS, we can use the command "mount", with NO ARGUMENTS, as in:
         $ mount

(See Figure 14-4, page 262, for an illustration).

##############################################################################################################
- The "mount()" and "umount()" system calls ALLOW a PRIVILEGED PROCESS ('CAP_SYS_ADMIN') to MOUNT and UNMOUNT
FILE SYSTEMS. MOST UNIX implementations PROVIDE VERSIONS of these SYSTEM CALLS. However, they are NOT
STANDARDIZED by SUSv3, and their operation VARIES BOTH ACROSS UNIX implementations and ACROSS FILE SYSTEMS.

- Before looking at these system calls, it is USEFUL to KNOW about THREE FILES that CONTAIN INFORMATION about the
FILE SYSTEMS that are CURRENTLY MOUNTED or CAN BE MOUNTED:
         a) A LIST of the CURRENTLY MOUNTED FILE SYSTEMS can be READ from the LINUX-SPECIFIC "/proc/mounts"
            VIRTUAL FILE. "/proc/mounts" is an INTERFACE to KERNEL DATA STRUCTURES, so it ALWAYS CONTAINS
            ACCURATE INFORMATION about mounted file systems. 

                Note:  With the ARRIVAL of the PER-PROCESS MOUNT NAMESPACE FEATURE mentioned earlier, each
                     process now has a "/proc/PID/mounts" file that LISTS the MOUNT POINTS constituting its
                     MOUNT NAMESPACE, and "/proc/mounts" is JUST a SYMBOLIC LINK to "/proc/self/mounts".

         b) The "mount(8)" and "umount(8)" commands AUTOMATICALLY MAINTAIN the file "/etc/mtab", which CONTAINS
            INFORMATION that is SIMILAR to that in "/proc/mounts", but SLIGHTLY MORE DETAILED. In particular,
            "etc/mtab" includes FILE SYSTEM-SPECIFIC OPTIONS given to "mount(8)", which are NOT SHOWN in
            "/proc/mounts". However, because the "mount()" and "umount()" system calls DON'T UPDATE "/etc/mtab",
            this file MAY BE INACCURATE if SOME APPLICATION that mounts or unmounts devices FAILS to UPDATE IT.

         c) The "/etc/fstab" file, MAINTAINED MANUALLY by the SYSTEM ADMINISTRATOR, contains DESCRIPTIONS of
            ALL AVAILABLE FILE SYSTEMS on a system, and is USED by the "mount(8)", "umount(8)", and "fsck(8)"
            commands.

- The "/proc/mounts", "/etc/mtab", and "/etc/fstab" files SHARE a COMMON FORMAT, described in the "fstab(5)"
manual page. Here is an EXAMPLE of a LINE from the "/proc/mounts" file:
         # /dev/sda9    /boot    ext3   rw   0 0

- This LINE contains SIX FIELDS:
    1) The NAME of the MOUNTED DEVICE;
    2) The MOUNT POINT for the DEVICE;
    3) The FILE-SYSTEM TYPE;
    4) MOUNT FLAGS. In the above example, "rw" indicates that the file system was MOUNTED READ-WRITE.
    5) A number used to CONTROL the OPERATION of FILE-SYSTEM BACKUPS by "dump(8)". This field and the next are
       ONLY USED in the "/etc/fstab" file; for "/proc/mounts" and "/etc/mtab", these fields are ALWAYS 0.
    6) A number used to CONTROL the ORDER in which fsck(8) CHECKS FILE SYSTEMS at SYSTEM BOOT TIME.

- The "getfsent(3)" and "getmntent(3)" manual pages DOCUMENT FUNCTIONS that can be USED to READ RECORDS from
these files.

--------------------------------------------------------------------------------------------------
- The "mount()" system call MOUNTS the FILE SYSTEM contained on the DEVICE SPECIFIED by "source" UNDER the
DIRECTORY (the "MOUNT POINT") SPECIFIED by "target":
        DEP: #include <sys/mount.h>         PROTO: int mount(const char *source, const char *target,
                                                             const char *fstype, unsigned long mountflags,
                                                             const void *data);
                                            RET: Returns 0 on success, or -1 on error.

- The names "source" and "target" are used for the first two arguments because "mount()" can PERFORM OTHER TASKS
than MOUNTING a DISK FILE SYSTEM under a DIRECTORY.

- The "fstype" argument is a string IDENTIFYING the TYPE of FILE SYSTEM contained on the DEVICE, such as
"ext4" or "btrfs".

- The "mountflags" argument is a BIT MASK constructed by ORing(|) ZERO OR MORE of the FLAGS shown in Table 14-1.

- The final "mount()" argument, "data", is a POINTER to a BUFFER OF INFORMATION whose INTERPRETATION DEPENDS on
the FILE SYSTEM. For MOST FILE-SYSTEM TYPES, this argument is a string consisting of a COMMA-SEPARATED OPTION
SETTINGS. A FULL LIST of these OPTIONS can be found in the "mount(8)" manual page (or the DOCUMENTATION for the
FILE SYSTEM CONCERNED, IF it is NOT DESCRIBED in "mount(8)").
    --------------
    | Table 14-1 |
    ------------------------------------------------------------------------------------------
    | Flag           | Purpose                                                               |
    ------------------------------------------------------------------------------------------
    | MS_BIND        | Create a BIND MOUNT (since Linux 2.4)                                 |
    | MS_DIRSYNC     | Make directory update SYNCHRONOUS (since Linux 2.6)                   |
    | MS_MANDLOCK    | Permit mandatory locking of files                                     |
    | MS_MOVE        | Atomically move mount point to new location                           |
    | MS_NOATIME     | Don't update last access time for files                               |
    | MS_NODEV       | Don't allow access to devices                                         |
    | MS_NODIRATIME  | Don't update last access time for directories                         |
    | MS_NOEXEC      | Don't allow programs to be executed                                   |
    | MS_NOSUID      | Don't allow programs to be executed                                   |
    | MS_RDONLY      | Read-only mount; files can't be created or modified                   |
    | MS_REC         | Recursive mount (since Linux 2.4.11)                                  |
    | MS_RELATIME    | Update last access time only if older than last modification time or  |
    |                | last status change time (since Linux 2.6.20)                          |
    | MS_REMOUNT     | Remount with new "mountflags" and "data"                              |
    | MS_STRICTATIME | Always update last access time (sine Linux 2.6.30)                    |
    | MS_SYNCHRONOUS | Make all file and directory updates synchronous                       |
    ------------------------------------------------------------------------------------------

(See pages 265-267 for a detailed description of these flags).

--------------------------------------------------------------------------------------------------
- The "umount()" system call UNMOUNTS a MOUNTED FILE SYSTEM:
        DEP: #include <sys/mount.h>         PROTO: int umount(const char *target);
                                            RET: Returns 0 on success, or -1 on error.

- The "target" argument SPECIFIES the MOUNT POINT of the FILE SYSTEM to be UNMOUNTED.

                Note:  On Linux 2.2 and EARLIER, the FILE SYSTEM can be IDENTIFIED in TWO WAYS:
                         1) By the MOUNT POINT;
                         2) By the NAME of the DEVICE CONTAINING the FILE SYSTEM;
                       Since KERNEL 2.4, Linux DOESN'T ALLOW the LATTER POSSIBILITY, because a SINGLE FILE SYSTEM
                     can now be MOUNTED at MULTIPLE LOCATIONS, so that SPECIFYING a FILE SYSTEM for "target"
                     would be AMBIGUOUS.

- It is NOT POSSIBLE to UNMOUNT a FILE SYSTEM that is "BUSY"; that is, IF there are OPEN FILES on the file system
or a PROCESS'S CURRENT WORKING DIRECTORY is somewhere IN the file system. Calling "umount()" on a BUSY FILE
SYSTEM yields the error 'EBUSY'.

- The "umount2()" system call is an EXTENDED VERSION of "umount()". It ALLOWS FINER CONTROL over the UNMOUNT
OPERATION via the "flags" argument:
        DEP: #include <sys/mount.h>         PROTO: int umount2(const char *target, int flags);
                                            RET: Returns 0 on success, or -1 on error.

- This "flags" bit-mask argument CONSISTS of ZERO OR MORE of the FOLLOWING VALUES (ORed together):
       - 'MNT_DETACH' (since Linux 2.4.11) - Perform a "LAZY" UNMOUNT. The MOUNT POINT is MARKED so that NO
                                             PROCESS can MAKE NEW ACCESSES to it, but PROCESSES that are ALREADY
                                             USING IT can CONTINUE to do so. The FILE SYSTEM is ACTUALLY
                                             UNMOUNTED when ALL PROCESSES CEASE USING THE MOUNT.

       - 'MNT_EXPIRE' (since Linux 2.6.8) - MARK the MOUNT POINT as "EXPIRED". If an initial "umount2()" call is
                                            made specifying this flag, and the MOUNT POINT is NOT BUSY, then the
                                            CALL FAILS with the error 'EAGAIN', but the MOUNTED POINT is MARKED
                                            to EXPIRE (if the MOUNT POINT is BUSY, then the CALL FAILS with the
                                            error 'EBUSY', and the MOUNT POINT is NOT MARKED to EXPIRE).
                                            A mount point remains expired as long as no process subsequently
                                            makes use of it. A second "umount2()" call specifying 'MNT_EXPIRE'
                                            will UNMOUNT an EXPIRED MOUNT POINT. This provides a MECHANISM to
                                            UNMOUNT a FILE SYSTEM that HASN'T BEEN USED for SOME PERIOD of time.
                                            This flag CAN'T BE SPECIFIED with 'MNT_DETACH' or 'MNT_FORCE'.

       - 'MNT_FORCE' - FORCE an UNMOUNT EVEN IF the DEVICE is BUSY (NFS mounts only). Employing this option can
                       CAUSE DATA LOSS.

       - 'UMOUNT_NOFOLLOW' (since Linux 2.6.34) - DON'T DEREFERENCE "target" if it is a SYMBOLIC LINK. This flag
                                                  is DESIGNED FOR USE in CERTAIN set-UID-root programs that
                                                  ALLOWS UNPRIVILEGED USERS to PERFORM UNMOUNTS, in order to
                                                  AVOID the SECURITY PROBLEMS that COULD OCCUR if "target" is a
                                                  SYMBOLIC LINK that is CHANGED to POINT to a DIFFERENT LOCATION.

##############################################################################################################
==> Mounting a File System at Multiple Mount Points <==

- In kernel versions BEFORE 2.4, a FILE SYSTEM could ONLY BE MOUNTED on a SINGLE MOUNT POINT. From kernel 2.4
ONWARD, a FILE SYSTEM can be MOUNTED at MULTIPLE LOCATIONS within the SINGLE DIRECTORY HIERARCHY. Because EACH
of the MOUNT POINTS SHOWS the SAME SUBTREE, CHANGES made via ONE MOUNT POINT are VISIBLE through the OTHER(S),
as demonstrated by the following shell session:
        $ su
        Password:
        # mkdir /testfs
        # mkdir /demo
        # mount /dev/sda12 /testfs
        # mount /dev/sda12 /demo
        # mount | grep sda12
        /dev/sda12 on /testfs type ext3 (rw)
        /dev/sda2 on /demo type ext3 (rw)
        # touch /testfs/myfile
        # ls /demo
        lost+found myfile

                Note:  It is because a DEVICE can be MOUNTED at MULTIPLE POINTS that the "umount()" system call
                     CAN'T TAKE a DEVICE NAME as its argument in Linux 2.4 and LATER.

--------------------------------------------------------------------------------------------------
==> Stacking Multiple Mounts on the Same Mount Point <==

- In kernel versions BEFORE 2.4, a MOUNT POINT could be USED ONLY ONCE. Since kernel 2.4, Linux ALLOWS MULTIPLE
MOUNTS to be STACKED on a SINGLE MOUNT POINT. Each NEW MOUNT HIDES the DIRECTORY SUBTREE PREVIOUSLY VISIBLE at
that mount point. When the MOUNT at the TOP OF THE STACK is UNMOUNTED, the PREVIOUSLY HIDDEN MOUNT becomes
VISIBLE ONCE MORE, as demonstrated by the following shell session:
        $ su
        Password:
        # mount /dev/sda12 /testfs
        # touch /testfs/myfile
        # mount /dev/sda13 /testfs
        # mount | grep testfs
        /dev/sda12 on /testfs type ext3 (rw)
        /dev/sda12 on /testfs type reiserfs (rw)
        # touch /testfs/newfile
        # ls /testfs
        newfile
        # umount /testfs
        # mount | grep testfs
        /dev/sda12 on /testfs type ext3 (rw)
        # ls /testfs
        lost+found myfile

- One use of MOUNT STACKING is to STACK a NEW MOUNT on an EXISTING MOUNT POINT that is BUSY. Processes that
HOLD FILE DESCRIPTORS OPEN, that are "chroot()-jailed", or that have CURRENT WORKING DIRECTORIES WITHIN the
OLD MOUNT POINT CONTINUE to OPERATE UNDER that MOUNT, but PROCESSES MAKING NEW ACCESSES to the MOUNT POINT use
the NEW MOUNT. Combined with a 'MNT_DETACH' unmount, this can provide a SMOOTH MIGRATION off a file system
WITHOUT NEEDING to TAKE the SYSTEM into SINGLE-USER MODE.

--------------------------------------------------------------------------------------------------
==> Mount Flags That Are Per-Mount Options <==

- In kernel versions BEFORE 2.4, there was a ONE-TO-ONE CORRESPONDENCE (bijection) between FILE SYSTEMS and
MOUNT POINTS. Because this NO LONGER HOLDS in Linux 2.4 and LATER, SOME of the "mountflags" values described
earlier can be SET on a PER-MOUNT BASIS. These flags are 'MS_NOATIME' (since Linux 2.6.16), 'MS_NODEV',
'MS_NODIRATIME' (since Linux 2.6.16), 'MS_NOEXEC', 'MS_NOSUID', 'MS_RDONLY' (since Linux 2.6.26), and
'MS_RELATIME'. The following shell sessions demonstrates this effect for the 'MS_NOEXEC' flag:
        $ su
        Password:
        # mount /dev/sda12 /testfs
        # mount -o noexec /dev/sda12 /demo
        # cat /proc/mounts | grep sda12
        /dev/sda12 /testfs ext3 rw 0 0
        /dev/sda12 /demo ext3 rw,noexec 0 0
        # cp /bin/echo /testfs
        # /testfs/echo "Art is something which is well done"
        Art is something which is well done
        # /demo/echo "Art is something which is well done"
        bash: /demo/echo: Permission denied.

--------------------------------------------------------------------------------------------------
==> Bind Mounts <==

- Starting with kernel 2.4, Linux PERMITS the CREATION of BIND MOUNTS. A "BIND MOUNT" (created using the mount()
'MS_BIND' flag) ALLOWS a DIRECTORY or a FILE to be MOUNTED at some OTHER LOCATION in the FILE-SYSTEM HIERARCHY.
This RESULTS in the DIRECTORY or FILE BEING VISIBLE in BOTH LOCATIONS. A BIND MOUNT is SOMEWHAT LIKE a HARD LINK,
but DIFFERS in TWO RESPECTS:
     1) A bind mount CAN CROSS FILE-SYSTEM MOUNT POINTS (and EVEN "chroot" jails);
     2) It is POSSIBLE to MAKE a BIND MOUNT for a DIRECTORY;

- We can create a bind mount from the shell using the "--bind" option to "mount(8)", as shown in the following
examples.

- In the first example, we BIND MOUNT a DIRECTORY at ANOTHER LOCATION and SHOW that FILES CREATED in ONE
DIRECTORY are VISIBLE at the OTHER LOCATION:
        $ su
        Passowrd:
        # pwd
        /testfs
        # mkdir d1             // Create directory to be bound at another location
        # touch d1/x           // Create file in the directory
        # mkdir d2             // Create mount point to which d1 will be bound
        # mount --bind d1 d2   // Create bind mount: d1 visible via d2
        # ls d2
        x
        # touch d2/y           // Create second file in directory d2
        # ls d1                // Verify that this change is visible via d1
        x  y

- In the second example, we BIND MOUNT a FILE at ANOTHER LOCATION and DEMONSTRATE that CHANGES to the file VIA
ONE MOUNT are VISIBLE VIA the OTHER MOUNT:
        # cat > f1                    // Create file to be bound to another location
        Change is always powerful. Let your hook be always cast.
        Type Control-D
        # touch f2                    // This is the new mount point
        # mount --bind f1 f2          // Bind f1 as f2
        # mount | egrep '(d1|f1)'     // See how mount points look
        /testfs/d1 on /testfs/d2 type none (rw,bind)
        /testfs/d2 on /testfs/f2 type none (rw,bind)
        # cat >> f2                   // Change f2
        In the pool here you least expect it, will be a fish.
        # cat f1                      // The change is visible via original file f1
        Change is always powerful. Let your hook be always cast.
        In the pool here you least expect it, will be a fish.
        # rm f2                       // Can'd do this because it is a mount point
        rm: cannot unlink 'f2': Device or resource busy
        # umount f2                   // So unmount
        # rm f2                       // Now we can remove f2

- One EXAMPLE of WHEN WE MIGHT USE a BIND MOUNT is in the CREATION of a "chroot" jail. RATHER than REPLICATING
VARIOUS STANDARD DIRECTORIES (such as "/lib") in the jail, we can SIMPLY CREATE BIND MOUNTS for these directories
WITHIN the jail.

--------------------------------------------------------------------------------------------------
==> Recursive Bind Mounts <==

- By DEFAULT, if we CREATE a BIND MOUNT for a DIRECTORY using 'MS_BIND', then ONLY THAT DIRECTORY is MOUNTED at
the NEW LOCATION; if there are ANY SUBMOUNTS under the SOURCE DIRECTORY, they are NOT REPLICATED under the mount
"target". Linux 2.4.11 ADDED the 'MS_REC' flag, which can be ORed with 'MS_BIND' as PART of the "flags" argument
to "mount()" so that submounts ARE replicated under the MOUNT TARGET. This is referred to as a "RECURSIVE BIND
MOUNT". The "mount(8)" command PROVIDES the "--rbind" option to ACHIEVE the SAME EFFECT from the SHELL.

- We begin by CREATING a DIRECTORY TREE (src1) mounted under "top". This tree INCLUDES a SUBMOUNT (src2) at
"top/sub".
        $ su
        Password:
        # mkdir top               // This is our top-level mount point
        # mkdir src1              // We'll mount this under top
        # touch src1/aaa
        # mount --bind src1 top   // Create a normal bind mount
        # mkdir top/sub           // Create directory for a submount under top
        # mkdir src2              // We'll mount this under top/sub
        # touch src2/bbb
        # mount --bind src2 top/sub  // Create a normal bind mount
        # find top                   // Verify contents under 'top' mount tree
        top
        top/aaa
        top/sub                      // This is the submount
        top/sub/bbb

- Now we CREATE ANOTHER BIND MOUNT (dir1) using 'top' as the SOURCE. Since this NEW MOUNT is NONRECURSIVE, the
SUBMOUNT is NOT REPLICATED:
        # mkdir dir1
        # mount --bind top dir1      // Here we use a normal bind mount
        # find dir1
        dir1
        dir1/aaa
        dir1/sub

- The ABSENCE of "dir1/sub/bbb" in the output of "find" SHOWS that the SUBMOUNT "top/sub" was NOT REPLICATED.

- Now we CREATE a RECURSIVE BIND MOUNT (dir2) using 'top' as the SOURCE:
        # mkdir dir2
        # mount --rbind top dir2
        # find dir2
        dir2
        dir2/aaa
        dir2/sub
        dir2/sub/bbb

- The PRESENCE of "dir2/sub/bbb" in the output of "find" SHOWS that the SUBMOUNT "top/sub" was REPLICATED.

##############################################################################################################
- All of the file systems we have described so far in this chapter RESIDE on DISKS. However, Linux ALSO SUPPORTS
the NOTION of "VIRTUAL FILE SYSTEMS" that RESIDE in MEMORY. To applications, these look just like any other file
system - the same operations ("open()", "read()", "write()", "link()", "mkdir()", and so on) can be APPLIED to
FILES and DIRECTORIES in such file systems. There is, however, ONE IMPORTANT DIFFERENCE: FILE OPERATIONS are
MUCH FASTER, since NO DISK ACCESS is INVOLVED.

- Various MEMORY-BASED FILE SYSTEMS have been DEVELOPED for Linux. The MOST SOPHISTICATED of these to date is the
"tmpfs" FILE SYSTEM, which FIRST APPEARED in Linux 2.4. The "tmpfs" file system DIFFERS from OTHER MEMORY-BASED
FILE SYSTEMS in that it is a "VIRTUAL" MEMORY FILE SYSTEM. This means that "tempfs" uses NOT ONLY RAM, but ALSO
the SWAP SPACE, if RAM is EXHAUSTED (although the "tmpfs" file system described here is LINUX-SPECIFIC, MOST
UNIX implementations PROVIDE SOME FORM of MEMORY-BASED FILE SYSTEM).

                Note:  The "tmpfs" file system is an OPTIONAL LINUX KERNEL COMPONENT that is CONFIGURED VIA the
                     "CONFIG_TMPFS" option.

- To CREATE a "tmpfs" file system, we use a command of the following form:
         # mount -t tmpfs source target

- The "source" can be ANY NAME; its ONLY SIGNIFICANCE is that it APPEARS in "/proc/mounts" and is DISPLAYED by
the "mount" and "df" commands. As usual, "target" is the MOUNT POINT for the FILE SYSTEM. Note that it is NOT
NECESSARY to use "mkfs" to CREATE a FILE SYSTEM FIRST, because the KERNEL AUTOMATICALLY BUILDS a FILE SYSTEM
as PART OF the "mount()" system call.

- As an EXAMPLE of the use of "tmpfs", we could EMPLOY MOUNT STACKING (so that we DON'T NEED to CARE if "/tmp"
is ALREADY in USE) and CREATE a "tmpfs" file system mounted on "tmp" as follows:
          # mount -t tmpfs newtmp /tmp
          # cat /proc/mounts | grep tmp
          newtmp /tmp tmpfs rw 0 0

- A command such as the above (or an EQUIVALENT ENTRY in /etc/fstab) is SOMETIMES USED to IMPROVE the PERFORMANCE
of applications (e.g., COMPILERS) that make HEAVY USE of the "/tmp" directory for CREATING TEMPORARY FILES.

- By DEFAULT, a "tmpfs" file system is PERMITTED to GROW to HALF THE SIZE of RAM, but the "size=nbytes mount"
option can be USED to SET a DIFFERENT CEILING for the FILE-SYSTEM SIZE, EITHER when the file system is CREATED
or DURING a LATER REMOUNT (a "tmpfs" file system CONSUMES ONLY AS MUCH MEMORY and SWAP SPACE as is CURRENTLY
REQUIRED for the FILES it HOLDS).

- If we UNMOUNT a "tmpfs" file system, or the SYSTEM CRASHES, then ALL DATA in the FILE SYSTEM is LOST; hence
the name "tmpfs".

- Aside from USE by USER APPLICATIONS, "tmpfs" file systems ALSO SERVE TWO SPECIAL PURPOSES:
        a) An INVISIBLE "tmpsf" file system, MOUNTED INTERNALLY by the KERNEL, is used for IMPLEMENTING System V
           SHAERD MEMORYand SHARED ANONYMOUS MEMORY MAPPINGS;

        b) A "tmpfs" file system MOUNTED at "/dev/shm" ("/run/shm" on some systems) is USED for the "glibc"
           implementation of POSIX shared memory and POSIX semaphores.

##############################################################################################################
- The "statvfs()" and "fstatvfs()" library functions OBTAIN INFORMATION about a MOUNTED FILE SYSTEM:
         DEP: #include <sys/statvfs.h>      PROTO: int statvfs(const char *pathname, struct statvfs *statvfsbuf);
                                            PROTO: int fstatvfs(int fd, struct statvfs *statvfsbuf);
                                            RET: Both return 0 on success, or -1 on error.

- The ONLY DIFFERENCE between these two functions is in HOW the FILE SYSTEM is IDENTIFIED. For "statvfs()", we
use "pathname" to SPECIFY the NAME of ANY FILE in the FILE SYSTEM. For "fstatvfs()", we SPECIFY an OPEN FILE
DESCRIPTOR, "fd", REFERRING to ANY FILE in the FILE SYSTEM. Both functions return a "statvfs" structure
CONTAINING INFORMATION about the FILE SYSTEM in the BUFFER pointed to by "statvfsbuf". This structure has the
following form:
         # struct statvfs{
         #    unsigned long f_bsize;    /* File-system block size (in bytes) */
         #    unsigned long f_frsize;   /* Fundamental file-system block size (in bytes) */

         #    fsblkcnt_t    f_blocks;   /* Total number of blocks in file system
         #                                 (in units of 'f_frsize') */
         #    fsblkcnt_t    f_bfree;    /* Total number of free blocks */
         #    fsblkcnt_t    f_bavail;   /* Number of free blocks available to unprivileged process */

         #    fsfilcnt_t    f_files;    /* Total number of i-nodes */
         #    fsfilcnt_t    f_ffree;    /* Total number of free i-nodes */
         #    fsfilcnt_t    f_favail;   /* Number of i-nodes available to unprivileged process
         #                                 (set to 'f_ffree' on Linux) */
         #    unsigned long f_fsid;     /* File-system ID */
         #    unsigned long f_flag;     /* Mount flags */
         #    unsigned long f_namemax;  /* Maximum length of filenames on this file system */
         # };

- The PURPOSE of MOST of the FIELDS in the "statvfs" structure is MADE CLEAR in the COMMENTS ABOVE. We note a
FEW FURTHER POINTS regarding some fields:
      - The 'fsblkcnt_t' and 'fsfilcnt_t' data types are INTEGER TYPES SPECIFIED by SUSv3.

      - For MOST Linux file systems, the VALUES of 'f_bsize' and 'f_frsize' are THE SAME. However, some file
        systems SUPPORT the NOTION of BLOCK FRAGMENTS, which can be USED to ALLOCATE a SMALLER UNIT OF STORAGE
        at the END of the FILE if a FULL BLOCK is NOT REQUIRED. This AVOIDS the WASTE OF SPACE that would
        OTHERWISE OCCUR if a FULL BLOCK was ALLOCATED. On such file systems, 'f_frsize' is the SIZE of a FRAGMENT
        and 'f_bsize' is the SIZE of a WHOLE BLOCK (the NOTION of FRAGMENTS in UNIX file systems FIRST APPEARED
        in the EARLY 1980s with the 4.2BSD Fast File System).

      - Many NATIVE UNIX and Linux file systems SUPPORT the NOTION of RESERVING a CERTAIN PORTION of the BLOCKS
        of a FILE SYSTEM for the SUPERUSER, so that IF the file system FILL UP, the SUPERUSER can STILL LOG IN
        to the system and do some work to RESOLVE the PROBLEM. If there are RESERVED BLOCKS in the file system,
        then the DIFFERENCE in VALUES of the 'f_bfree' and 'f_bavail' fields in the "statvfs" structure TELLS US
        HOW MANY BLOCKS are RESERVED.

      - The 'f_flag' field is a BIT MASK of the FLAGS USED to MOUNT the FILE SYSTEM; that is, it CONTAINS
        SIMILAR INFORMATION to the "mountflags" argument given to "mount(2)". However, the CONSTANTS used for the
        BITS in this field have NAMES STARTING with "ST_" INSTEAD OF the "MS_" used for "mountflags".
        SUSv3 ONLY REQUIRES the "ST_RDONLY and "ST_NOSUID" constants, but the "glibc" implementation SUPPORTS
        a FULL RANGE of CONSTANTS with NAMES CORRESPONDING to the "MS_*" constants described for the "mount()
        mountflags" argument.

      - The 'f_fsid' field is USED to RETURN a UNIQUE IDENTIFIER for the FILE SYSTEM - for example, a value
        BASED on the IDENTIFIER of the DEVICE on which the FILE SYSTEM RESIDES. On OLDER LINUX KERNELS, MANY
        TYPES of FILE SYSTEMS return 0 in this field.

- SUSv3 SPECIFIES BOTH "statvfs()" AND "fstatvfs()". On Linux (as on SEVERAL OTHER UNIX implementations), these
functions are LAYERED ON TOP of the QUITE SIMILAR "statfs()" and "fstatfs()" system calls (SOME UNIX
implementations provide a "statfs()" system call, but DON'T PROVIDE "statvfs()"). The PRINCIPAL DIFFERENCES
(ASIDE from some DIFFERENTLY NAMED FIELDS) are as follows:
       a) The "statvfs()" and "fstatvfs()" functions return the 'f_flag' field, giving INFORMATION about the
          FILE-SYSTEM MOUNT FLAGS (the "glibc" implementation OBTAINS this INFORMATION by SCANNING
          "/proc/mounts" or "/etc/mtab").

       b) The "statfs()" and "fstatfs()" system calls return the field 'f_type', giving the TYPE of the FILE
          SYSTEM (e.g., the VALUE 0xEF53 INDICATES that this is an "ext2" FILE SYSTEM).

